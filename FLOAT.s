*************************************************
*	Adapted from Apple Technical Information Library. ArticleID: TECHINFO-0000074
*	http://apple2.org.za/gswv/a2zine/GS.WorldView/Resources/GS.TECH.INFO/AppleSoft/Floating.Point.Math.Package.1.txt
*************************************************



*************************************************
*	Constants
*
*************************************************

RND				EQU		$00C9	;	pseudorandom number, generated by FRND ($EFAE)

NEG32768		EQU		$E0FE	;	-32768

POS1			EQU		$E913	;	+1

SQRONEHALF		EQU		$E92D	;	SQR(1/2)

SQR2			EQU		$E932	;	SQR(2)

MINUSONEHALF	EQU		$E937	;	-1/2

LN2				EQU		$E93C	;	Natural Log(2)

TEN				EQU		$EA50	;	+10

ONEBILLION		EQU		$ED14	;	1,000,000,000

ONEHALF			EQU		$EE64	;	+1/2

LOG2BASEE		EQU		$EEDB	;	Log(2) Base e

PIOVER2			EQU		$F063	;	Pi/2

PITIMES2		EQU		$F06B	;	Pi * 2

ONEFOURTH		EQU		$F070	;	+1/4



*************************************************
*	FLOATING POINT REGISTER MOVE ROUTINES
*
*************************************************

MOVFM		EQU		$EAF9
;	Moves the number in memory Y,A points to into FAC.  On exit A and Z reflect FACEXP.

MOV2F		EQU		$EB1E
;	Pack FAC and temporarily moves it into register 2.  On exit A and Z reflect FACEXP.

MOV1F		EQU		$EB21
;	Pack FAC and moves it temporarily into register 1.  On exit A and Z reflect FACEXP.

MOVML		EQU		$EB23
;	Pack FAC and move it into zero page area starting at X.  On exit A and Z reflect FACEXP.

MOVMF		EQU		$EB2B
;	Pack FAC and move it into memory pointed to by Y,X.  On exit A and Z reflect FACEXP.

MOVFA		EQU		$EB53
;	Move ARG into FAC.  On exit A and Z reflect FACEXP.

MOVAF		EQU		$EB63
;	Move FAC into ARG.  On exit A and Z reflect FACEXP.

CONUPK		EQU		$E9E3
;	Load ARG from memory pointed to by Y,A.  On exit A and Z reflect FACEXP.

;	SUMMARY OF MOVES:
;	 FAC   => (Y,A)  EB2B    MOVMF
;	
;	 FAC   => (0,X)  EB23    MOVML
;	
;	 FAC   => TEMP1  EB21    MOV1F
;	
;	 FAC   => TEMP2  EB1E    MOV2F
;	
;	 FAC   =>  ARG   EB63    MOVAF
;	
;	
;	 ARG   =>  FAC   EB53    MOVFA
;	
;	
;	 (Y,A) =>  FAC   EAF9    MOVFM
;	
;	 (Y,A) =>  ARG   E9E3    CONUPK



*************************************************
*	FLOATING POINT OPERATORS
*	
*************************************************
;	The following routines require that A and Z reflect FACEXP.  
;	Even though FAC move routines set up A and Z, a LDA $9D will insure their proper values.

FMULT		EQU		$E97F
;	Multiply the FAC by the number in memory pointed to by Y,A.

FMULTT		EQU		$E982
;	Multipy FAC and ARG.  On entry A and Z must reflect FACEXP.

FDIV		EQU		$EA66
;	Divide the number in memory pointed to by Y,A by FAC.

FDIVT		EQU		$EA69
;	Divide ARG by FAC.  On entry A and Z must reflect FACEXP.

FADD		EQU		$E7BE
;	Add the number Y,A points to in memory to FAC.

FADDT		EQU		$E7C1
;	Add FAC and ARG.  On entry A and Z must reflect FACEXP.

FSUB		EQU		$E7A7
;	Subtract FAC from the number Y,A points to in memory.

FSUBT		EQU		$E7AA
;	Subtract FAC from ARG.  On entry A and Z must reflect FACEXP.



*************************************************
*	TRANSCENDENTAL OPERATORS
*
*************************************************

FPWRT		EQU		$EE97
;	Raise ARG to the FAC power.  On entry A and Z must reflect the value of FACEXP.

SQR		EQU		$EE8D
;	Takes the square root of FAC

LOG		EQU		$E941
;	Log base e of FAC

EXP		EQU		$EF09
;	Raise e to the FAC power

COS		EQU		$EFEA
;	Returns the cosine of the FAC in radians.

SIN		EQU		$EFF1
;	Returns the sine of the FAC in radians.

TAN		EQU		$F03A
;	Returns the tangent of the FAC in radians.

ATN		EQU		$F09E
;	Returns the inverse-tangent of the FAC in radians.



*************************************************
*	OTHER OPERATORS
*
*************************************************

SGN		EQU		$EB90
;	Modifies the value of the FAC depending on its value on entry.  On exit:
;	
;	      FAC =  1  if FAC was greater than 0
;	      FAC =  0  if FAC was equal to 0
;	      FAC = -1  if FAC was less than 0

ABS		EQU		$EBAF
;	Absolute value of FAC.  If FAC is less than 0 then FAC = -FAC.

INT		EQU		$EC23
;	Greatest integer value of FAC.  Uses QINT and floats the result.

FRND		EQU		$EFAE
;	Form a pseudo-random number in FAC and update RND at 00C9.

SIGN		EQU		$EB82
;	Set A according to the value of FAC.  On exit:
;	
;	      A = 1  if FAC is positive
;	      A = 0  if FAC = 0
;	      A = FF if FAC is negative

FCOMP		EQU		$EBB2
;	Compare FAC and a packed number in memory pointed to by Y,A.  On exit:
;	
;	      A = 1  if (Y,A) < FAC
;	      A = 0  if (Y,A) = FAC
;	      A = FF if (Y,A) > FAC

NEGOP		EQU		$EED0
;	FAC = -FAC

FADDH		EQU		$E7A0
;	Add 1/2 to FAC

DIV10		EQU		$EA55
;	Divide FAC by 10. Returns positive numbers only.

MUL10		EQU		$EA39
;	Multiply FAC by 10.  Works for both positive and negative numbers.



*************************************************
*	LOWER LEVEL INTERFACE ROUTINES
*
*************************************************

FOUT		EQU		$ED34
;	FOUT creates an ASCII string in FBUFFR equivalent to the value of FAC.  
;	On exit Y,A points to the string, which ends with an ASCII null.  
;	FAC is scrambled.  Use STROUT to print the number.

SNGFLT		EQU		$E301
;	SNGFLT converts the unsigned number in Y to a floating point number in FAC.

GIVAYF		EQU		$E2F2
;	GIVAYF converts the unsigned number in Y,A to a floating point number in FAC.

FLOAT		EQU		$EB93
;	FLOAT converts the signed number in A to a floating point number in FAC.

CONINT		EQU		$E6FB
;	CONINT converts FAC into a single byte integer in X and FACLO.  
;	CONINT normally exits through CHRGET unless FAC is greater than 255 or less than 0,
;	when it exits via ILLEGAL QUANTITY ERROR.

AYINT		EQU		$E10C
;	If FAC is less than +32767 and greater than -32767, then execute QINT.
;	Otherwise AYINT exits via ILLEGAL QUANTITY ERROR.

QINT		EQU		$EBF2
;	Quick greatest integer function.  Leaves INT(FAC) in FACHO,MO,LO signed.
;	QINT assumes that the absolute value of the FAC is less than 8388608 (2^23rd power).

GETADR		EQU		$E752
;	GETADR converts the number in FAC to a 2 byte, unsigned integer in LINNUM.
;	When FAC is greater than 65535 or less than -65535, GETADR exits via ILLEGAL QUANTITY ERROR.

GETNUM		EQU		$E746
;	GETNUM fetches a 2 byte number, a comma and an unsigned, single byte number from TXTPTR.  
;	The first number is stored in LINNUM, while the second is returned to the X register.  
;	On entry TXTPTR points to the first character of the formula for the first number.  
;	GETNUM uses FRNUM, GETADR, CHKCOM and GETBYT.

COMBYTE		EQU		$E74C
;	COMBYTE checks for a comma, then fetches an unsigned, single byte number returned in X.  
;	On entry TXTPTR points to the comma.  COMBYTE uses CHKCOM and GETBYT.

FRMEVL		EQU		$DD7B
;	FRMEVL evaluates the formula at TXTPTR using CHRGET, then leaves the result in FAC.  
;	On entry, TXTPTR points to the first character of the formula, while on exit points to the terminator.  
;	"A" does not contain the terminator.  The format of the temporary result on the stack is:
;	
;	      The address of the operator routine.
;	      The floating point temporary result.
;	      The precedence of the operator.
;	
;	FRMEVL, the main subroutine for the commands that use formulas, works for both strings and numbers.  
;	If the formula is a string literal, FRMEVL gobbles the opening quote, then executes STRLIT and ST2TXT.

FRMNUM		EQU		$DD67
;	FRMNUM evaluates the formula at TXTPTR, puts it in FAC, then makes sure the result is numeric.  
;	On entry TXTPTR points to the first character of the formula.  
;	FRMNUM exits through TYPE MISMATCH ERROR if the result is a string.

FIN		EQU		$EC4A
;	FIN inputs a floating point number into FAC from CHRGET.  
;	FIN assumes the 6502 registers and A were set up by the CHRGET that fetched the first digit.
;	FIN only operates on numeric constants, not formulas.

